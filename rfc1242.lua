-- vim:ts=4:sw=4:noexpandtab
--- This script can be used to determine if a device is affected by the corrupted packets
--  that are generated by the software rate control method.
--  It generates CBR traffic via both methods and compares the resulting latency distributions.
--  TODO: this module should also test L3 traffic (but not just L3 due to size constraints (timestamping limitations))
local dpdk		= require "dpdk"
local memory	= require "memory"
local ts		= require "timestamping"
local device	= require "device"
local filter	= require "filter"
local timer		= require "timer"
local stats		= require "stats"
local hist		= require "histogram"

-- required here because this script creates *a lot* of mempools
memory.enableCache()

local REPS = 1
local run_time = 30
local FRAME_SIZE = 64
local NR_FLOWS = 1024
local BIDIREC = 0
local TX_PORT = 0
local RX_PORT = 1
local MAX_PCT_LOSS = 0
local LINE_RATE = 10000000000 -- 10Gbps
local RATE_RESOLUTION = 0.02
local ETH_DST   = "10:11:12:13:14:15" -- src mac is taken from the NIC
local IP_SRC    = "192.168.0.1"
local IP_DST    = "10.0.0.1"
local PORT_SRC  = 1234
local NUM_FLOWS = 256 -- src ip will be IP_SRC + random(0, NUM_FLOWS - 1)

function master(...)
	local txPort, rxPort, frame_size, bidirec, max_pct_loss, num_flows, maxRate = tonumberall(...)
	if not txPort or not rxPort then
		errorf("usage: txPort rxPort [frame_size bidirec max_pct_loss num_flows max_rate]")
	end
	frame_size = frame_size or FRAME_SIZE
	bidirec = bidirec or BIDIREC
	max_pct_loss = max_pct_loss or MAX_PCT_LOSS
	maxRate = maxRate or (LINE_RATE /(frame_size*8 +64 +96) /1000000) --maxRate is in millions per second
	num_flows = num_flows or NUM_FLOWS
	rateResolution = RATE_RESOLUTION

	printf("bidirec: %d", bidirec);
	printf("max_rate: %.2f", maxRate);
	printf("num_flows: %d", num_flows);
	printf("rate_resolution: %.2f", rateResolution);
	printf("max_pct_loss: %.2f", max_pct_loss);

	local txDev1 = device.config(txPort, 1, 1)
	local rxDev1 = device.config(rxPort, 1, 1)
	local txQueue1 = txDev1:getTxQueue(0)
	rxDev1:l2Filter(0x1234, filter.DROP)

	if (bidirec == 1) then
		txDev2 = device.config(rxPort, 1, 1)
		rxDev2 = device.config(txPort, 1, 1)
		txQueue2 = txDev2:getTxQueue(0)
		rxDev2:l2Filter(0x1234, filter.DROP)
	end

	device.waitForLinks()
	local prevRate = 0
	local prevPassRate = 0
	local prevFailRate = maxRate
	local rate = maxRate
	local cadence = 0

	frame_loss1 = 0
	frame_loss2 = 0
	method = "software"
	while ( math.abs(rate - prevRate) > rateResolution ) do

		if (bidirec == 1) then
			printf("Testing bidirectional frame rate (millions per second) with %s rate control: %.2f", method, rate * 2)
			txQueue1:setRateMpps(method == "hardware" and rate or 0)
			loadTask1 = dpdk.launchLua("loadSlave", txQueue1, rxDev1, method == "software" and rate, frame_size, run_time, num_flows)
			txQueue2:setRateMpps(method == "hardware" and rate or 0)
			loadTask2 = dpdk.launchLua("loadSlave", txQueue2, rxDev2, method == "software" and rate, frame_size, run_time, num_flows)
			frame_loss1 = loadTask1:wait()
			frame_loss2 = loadTask2:wait()
			printf("frame loss1 pct: %.2f\n", frame_loss1);
			printf("frame loss2 pct: %.2f\n", frame_loss2);
			printf("max loss pct: %.2f\n", max_pct_loss);
		else
			printf("Testing unidirectional frame rate (millions per second) with %s rate control: %.2f", method, rate)
			txQueue1:setRateMpps(method == "hardware" and rate or 0)
			loadTask1 = dpdk.launchLua("loadSlave", txQueue1, rxDev1, method == "software" and rate, frame_size, run_time, num_flows)
			frame_loss1 = loadTask1:wait()
			printf("frame loss1 pct: %.2f\n", frame_loss1);
			printf("max loss pct: %.2f\n", max_pct_loss);
		end
		
		prevRate = rate
	        if frame_loss1 > max_pct_loss or frame_loss2 > max_pct_loss then --failed to have <= max_pct_loss, lower rate
			prevFailRate = rate
			rate = ( prevPassRate + rate ) / 2
		else --acceptable packet loss, increase rate
			prevPassRate = rate
			rate = (prevFailRate + rate ) / 2
		end
		printf("\n")
		dpdk.sleepMillis(500)
		if not dpdk.running() then
			break
		end
	end

	if (bidirec == 1) then
		printf("The maximum bidirectional frame rate (millions per second) using a frame size of %d, at which none of the offered frames are dropped by the DUT: %.2f\n", frame_size, prevPassRate * 2);
	else
		printf("The maximum unidirectional frame rate (millions per second) using a frame size of %d, at which none of the offered frames are dropped by the DUT: %.2f\n", frame_size, prevPassRate);
	end

	run_time = run_time * 10
	frame_loss1 = 0
	frame_loss2 = 0
	if (bidirec == 1) then
		printf("Starting final validation of the maximum frame rate %.2f (millions per second) with a frame size of %d (%d seconds)\n", prevPassRate * 2, frame_size, run_time, num_flows);
		printf("Testing bidirectional frame rate (millions per second) with %s rate control: %.2f", method, prevPassRate * 2)
		rate = prevPassRate
		txQueue1:setRateMpps(method == "hardware" and rate or 0)
		loadTask1 = dpdk.launchLua("loadSlave", txQueue1, rxDev1, method == "software" and rate, frame_size, run_time, num_flows)
		txQueue2:setRateMpps(method == "hardware" and rate or 0)
		loadTask2 = dpdk.launchLua("loadSlave", txQueue2, rxDev2, method == "software" and rate, frame_size, run_time, num_flows)
		frame_loss1 = loadTask1:wait()
		frame_loss2 = loadTask2:wait()
		dpdk.sleepMillis(500)
		printf("Finshed final validation of the maximum frame rate %.2f (millions per second) with a frame size of %d\n", rate * 2, frame_size);
	else
		printf("Starting final validation of the maximum frame rate %.2f (millions per second) with a frame size of %d (%d seconds)\n", prevPassRate, frame_size, run_time, num_flows);
		printf("Testing unidirectional frame rate (millions per second) with %s rate control: %.2f", method, prevPassRate)
		rate = prevPassRate
		txQueue1:setRateMpps(method == "hardware" and rate or 0)
		loadTask1 = dpdk.launchLua("loadSlave", txQueue1, rxDev1, method == "software" and rate, frame_size, run_time, num_flows)
		frame_loss1 = loadTask1:wait()
		dpdk.sleepMillis(500)
		printf("Finshed final validation of the maximum frame rate %.2f (millions per second) with a frame size of %d\n", rate, frame_size);
	end

	if frame_loss1 > max_pct_loss or frame_loss2 > max_pct_loss then 
		printf("Final validation failed\n")
	else
		printf("Final validation passed\n")
	end
end

function loadSlave(queue, rxDev, rate, frame_size, run_time, num_flows)
	-- TODO: this leaks memory as mempools cannot be deleted in DPDK
	-- local mem = memory.createMemPool(function(buf)
		-- buf:getEthernetPacket():fill{
			-- ethType = 0x1234,
		-- }
	-- end)

	local frame_size_without_crc = frame_size - 4
	local mem = memory.createMemPool(function(buf)
		buf:getUdpPacket():fill{
			pktLength = frame_size_without_crc, -- this sets all length headers fields in all used protocols
			ethSrc = queue, -- get the src mac from the device
			ethDst = ETH_DST,
			-- ipSrc will be set later as it varies
			ip4Dst = IP_DST,
			udpSrc = PORT_SRC,
			udpDst = port,
			-- payload will be initialized to 0x00 as new memory pools are initially empty
		}
	end)
	local bufs = mem:bufArray()
	local runtime = timer:new(run_time)
	local rxStats = stats:newDevRxCounter(rxDev, "plain")
	local txStats = stats:newDevTxCounter(queue, "plain")
	local txDev
	local count = 0
	local baseIP = parseIPAddress(IP_SRC)
	while runtime:running() and dpdk.running() do
		bufs:alloc(frame_size_without_crc)
                for _, buf in ipairs(bufs) do
			local pkt = buf:getUdpPacket()
			-- Using random here tends to slow down the Tx rate
			-- pkt.ip4.src:set(baseIP + math.random(num_flows) - 1)
			-- For now, just increment with count and limit with num_flows
			-- Later, maybe consider pre-allocating a list of random IPs
			pkt.ip4.src:set(baseIP + count % num_flows)
		end
		if rate then
			for _, buf in ipairs(bufs) do
				buf:setRate(rate)
			end
			queue:sendWithDelay(bufs)
		else
			queue:send(bufs)
		end
		rxStats:update()
		txStats:update()
		count = count + 1
	end
	dpdk.sleepMillis(500)
	rxStats:update()
	txStats:update()
	txStats:finalize()
	rxStats:finalize()
	local loss = txStats.total - rxStats.total
	if (loss < 0 ) then
		loss = 0
	end
	local pct_loss = loss / txStats.total * 100
	printf("loop count: %d  frames dropped: %d (%.2f%%)", count, loss, loss / txStats.total * 100)
	return pct_loss
end


